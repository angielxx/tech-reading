# 5. 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

> 메모이제이션 기법은 언제 사용하는 것이 좋을까?

- 무거운 연산의 기준은 무엇잉ㄹ까?
- 렌더링 비용과 메모이제이션 비용 중 어떤 게 더 비싼 걸까?
- ...

## 1) 주장 1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

> 메모이제이션에도 비용이 든다.

- 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업
- 이전 결과물을 저장해 두었다가 다시 꺼내오는 작업

*섣부른 최적화: premature optimization, premature memoization

- 개발자 도구나 useEffect를 사용해 실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에서만 최적화하기

## 2) 주장 2: 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션 해버리자.

만약 어떤 컴포넌트의 렌더링이 자주 일어나며, 그 렌더링 사이에 비싼 연산이 포함돼 있고, 심지어 그 컴포넌트가 자식 컴포넌트 또한 많이 가지고 있다면 memo나 다른 메모이제이션 방법을 사용하는 것이 이점일 때가 있다.

- 옵션 1 : memo를 컴포넌트 사용에 따라 잘 살펴보고 일부에만 적용하는 방법
- 옵션 2 : 일단 그냥 다 적용하는 방법

> 결론 : 최적화에 대한 확신이 없다면 가능한 한 모든 곳에 메모이제이션을 활용한 최적화를 적용

- 메모이제이션은 하지 않는 것보다 메모이제이션 했을 때 더 많은 이점을 누릴 수 있다.
- memo를 하지 않았을 때 발생할 수 있는 문제..
  - 렌더링
  - 컴포넌트 내부 로직 재실행
  - 모든 자식 컴포넌트에서 위 두 가지가 반복 발생
  - 리액트가 구 트리와 신규 트리를 비교

## 3) 결론 및 정리

- 조금이라도 로직이 들어간 컴포넌트는 메모이제이션이 성능 향상에 도움을 줄 가능성이 크다.
- 성능에 대해서 지속적으로 모니터링하고 관찰하는 것보다 오히려 '섣부른 메모이제이션 최적화'가 주는 이점이 더 클 수 있다.
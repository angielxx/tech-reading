# 1. 리액트의 모든 훅 파헤치기

> 리액트 함수 컴포넌트에서 가장 중요한 훅

## 1) useState

### useState 구현 살펴보기

```
function Component() {
    const [_, triggerRender] = useState()

    let state = 'hello'

    function handleButtonClick() {
        state = 'hi'
        triggerRender()
    }

    return (
        <>
            <hi>{state}</hi>
            <button onClick={handleButtonClick}>hi</button>
        </>
    )
}
```

> 위 코드에서 버튼을 클릭해도 화면에 렌더링되는 state의 값이 hi로 바뀌지 않는 이유는?

리액트의 렌더링은 함수 컴포넌트에서 반환한 결과물인 return 값을 비교해 실행된다. 매번 렌더링이 발생될 때마다 함수는 다시 새롭게 실행되고, 새롭게 실행되는 함수에서 state는 매번 hello로 초기화되므로 아무리 state를 변경해도 다시 hello로 초기화된다.


### useState 내부 구현

> useState 훅의 결괏값은 어떻게 함수가 실행돼도 그 값을 유지하고 있을까?

함수의 실행이 끝났음에도 함수가 선언된 환경을 기억할 수 있는 방법인 클로저를 활용하여 함수 컴포넌트 환경에서 state의 값을 유지하고 사용하고 있다.

### 게으른 초기화

게으른 초기화란, useState의 인수로 함수를 넘기는 것.

게으른 초기화 함수는 최초 state가 처음 만들어질 때만 사용되며, 리렌더링에서는 실행되지 않는다.

> 게으른 최적화 사용 경우

- localStorage, sessionStorage에 대한 접근
- map, filter, find과 같은 배열에 대한 접근
- 초깃값 계산을 위해 함수 호출이 필요할 때

## 2) useEffect

useEffect는 애플리케이션 내 컴포넌ㅌ의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 매커니즘

### useEffect란?

> useEffect는 어떻게 의존성 배열이 변경된 것을 알고 실행될까?

특별한 기능을 통해 값의 변화를 관찰하는 것이 아니고, 렌더링할 때마다 의존성에 있는 값을 보면서 이 의존성의 값이 이전과 다른 게 하나라도 있으면 부수 효과를 실행하는 평범한 함수다.

### 클린업 함수의 목적

클린업 함수는 이전 state를 참조해 실행된다.

> 클린업 함수는 비록 새로운 값을 기반으로 렌더링 된 뒤에 실행되지만 이 변경된 값을 읽는 것이 아니라 useEffect 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행된다.

클린업 함수는 어떤 렌더링이 끝나고 실행되는 것이 아니라, 이전 렌더링에서 정의 후 다음 렌더링 때 이전의 클린업 함수가 존재한다면 그 클린업 함수를 실행한 뒤에 useEffect의 콜백 함수를 실행하는 것이다.

언마운트 개념과는 차이가 있다. 클린업 함수는 함수 컴포넌트가 리렌더링됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는 말 그대로 이전 상태를 '청소'해 주는 개념이다.

### 의존성 배열

- 빈 배열인 경우 : 비교할 의존성이 없다고 판단해 최초 렌더링 직후에 실행된 다음부터는 실행되지 않음
- 아무 값도 넘기지 않는 경우 : 의존성을 비교할 필요 없이 렌더링할 때마다 실행이 필요하다고 판단 (컴포넌트가 렌더링 됐는지 확인하기 위한 방법으로 사용)

```
useEffect(() => {
    console.log('컴포넌트 렌더링됨')
})
```

```
// 1
function Component(){
    console.log('렌더링됨')
}

// 2
function Component(){
    useEffect(() => {
        console.log('렌더링됨')
    })
}
```

차이점

1. 함수 내부에서의 직접 실행은 컴포넌트가 렌더링되는 도중에 실행된다. 함수 컴포넌트가 실행될 때 함께 실행되므로, 함수 컴포넌트의 반환을 지연시키는 행위다. 즉, 무거운 작업일 경우 렌더링을 방해하므로 성능에 악영향을 미칠 수 있다.
2. useEffect는 컴포넌트 렌더링의 부수 효과, 즉 컴포넌트 렌더링이 완료된 이후에 실행된다.

### useEffect의 구현

> 핵심은 의존성 배열의 이전 값과 현재 값의 '얕은 비교'

```
let isDependenciesChanged = previousDependencies
    ? dependencies.some(
        (value, idx) => !Object.is(value, previousDependencies[idx])
    ) : true
```

### useEffect 사용할 때 주의할 점

#### eslint-disable-line react-hooks/exhaustive-deps 주석 자제

useEffect 인수 내부에서 사용하는 값 중 의존성 배열에 포함돼 있지 않은 값이 있을 때 발생하는 경고

의도치 못한 버그를 만들 가능성이 큼

#### useEffect의 첫 번째 인수에 함수명을 부여하라

useEffect의 코드가 복잡하고 많아질 수록 무슨 일을 하는 useEffect 코드인지 파악하기 어려워진다. 기명 함수를 

```
useEffect(
    function logActiveUser(){
        loggin(user.id)
    },
    [user.id]
)
```

#### 거대한 useEffect를 만들지 마라

useEffect 부수 효과의 크기가 커질수록 어플리케이션 성능에 악영향을 미친다. 부득이하게 큰 useEffect를 만들어야 한다면 적은 의존성 배열을 사용하는 여러 개의 useEffect로 분리하는 것이 좋다.

#### 불필요한 외부 함수를 만들지 마라

useEffect가 실행하는 콜백 또한 불필요하게 존재해서는 안된다.
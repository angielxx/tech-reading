# 1. JSX란?

- JSX는 리액트가 등장하면서 메타에서 소개한 새로운 구문
- 하지만 리액트에서만 사용하라는 법은 없음

> JSX는 V8, Deno와 같은 자바스크립트 엔진이나 브라우저에 의해 실행되거나 표현되는 구문이 아님

- JSX를 포함한 코드는 반드시 트랜스파일러를 거쳐야 자바스크립트 런타임이 이해할 수 있는 코드로 변환된다.

> JSX의 목표 : 자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성하는데 도움

- JSX 내부에 트리 구조로 표현하고 싶은 다양한 것들을 작성하고, 트랜스파일을 거쳐 자바스크립트가 이해하는 코드로 변경하는 것이 목표
- JSX는 HTMl, XML 외에도 다른 구문으로 확장될 수 있게끔 고려돼 있음

## 1) JSX의 정의

JSX 컴포넌트

- JSXElement
- JSXAttributes
- JSXChildren
- JSXStrings

### JSXElement

- JSX를 구성하는 가장 기본 요소
- HTML의 elememt와 비슷한 역할

### JSXAttributes

- JSXElement에 부여할 수 있는 속성

### JSXChildren

- JSXElement의 자식 값
- JSX는 트리 구조를 나타내기 위해 만들어졌기 때문에 JSX로 부모와 자식 관게를 나타낼 수 있음

### JSXStrings

- HTML에서 사용 가능한 문자열은 모두 JSXStrings에서도 사용 가능

## 3) JSX는 어떻게 자바스크립트에서 변환될까?

`@babel/plugin-transform-react-jsx`

- 리액트에서 JSX를 변환하는 플러그인
- JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환

```
// JSX 코드

const ComponentA = <A required={true}>Hello World</A>

const ComponentB = <>Hello World</>

const ComponentC = (
  <div>
    <span>Hello World</span>
  </div>
)
```

```
// 변환된 코드
'use strict'

var ComponentA = React.createElement(
  A,
  {
    required: true,
  },
  'Hello World'
)

var ComponentB = React.createElemet(React.Fragment, null 'Hello World')

var ComponentC = React.createElement(
  'div',
  null,
  React.createElement('span', null, 'Hello World')
)
```

```
// 변환된 코드 (바벨 7.9.0 이후)
'use strict'

var _jsxRuntime = require('custom-jsx-library/jsx-runtime')

var ComponentA = (0, _jsxRuntime.jsx)(A, {
  required: true,
  children: 'Hello World',
})

var ComponentB = (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
  children: 'Hello World',
})

var ComponentC = (0, _jsxRuntime.jsx)('div', {
  children: (0, _jsxRuntime.jsx)('span', {
    children: 'Hello World'
  })
})
```

# 2. 가상 DOM과 리액트 파이버

## 1) DOM과 브라우저 렌더링 과정

### DOM(Document Object Model)

- 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보

### 브라우저 렌더링 과정

1. HTML 다운
2. HTML 파싱하여 DOM 노드로 구성된 DOM 트리 구성
3. 2.에서 CSS 파일 만나면 CSS 파일 다운로드
4. CSS 파싱하여 CSS 노드로 구성된 CSSOM 트리 구성
5. DOM 노드를 순회하며 사용자 눈에 보이는 노드만 방문
6. 5.에서 제외된 눈에 보이는 노드 대상으로 CSS 스타일 정보를 찾고 적용
   1. 레이아웃 : 좌표 계산
   2. 페인팅 : 색 등 그림

## 2) 가상 DOM의 탄생 배경

- 인터랙션에 따른 DOM의 최종 결과를 간편하게 제공 : DOM의 모든 변경 사항을 추적하는 것이 아니라, 결과적으로 만들어지는 DOM 결과물만 알도록 함

### 가상 DOM

- 리액트가 관리하는 가상의 DOM
- 웹페이지가 표시해야 할 DOM을 메모리에 저장하고, 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저 DOM에 반영

> 가상 DOM의 관리가 일반적인 DOM 관리(브라우저) 보다 빠르다?는 것은 사실이 아님

## 3) 가상 DOM을 위한 아키텍처, 리액트 파이버

리액트는 React Fiber를 통해 가상 DOM과 렌더링 과정 최적화를 수행

### 리액트 파이버란?

- 리액트 파이버는 평범한 자바스크립트 객체
- 파이버 재조정자(fiber reconciler) : 가상 DOM, 실제 DOM을 비교해 변경 사항을 수집하고, 변경 정보를 가지고 있는 파이버 기준으로 화면에 렌더링 요청
- 재조정(reconciliation) : 가상 DOM과 실제 DOM을 비교하는 알고리즘

#### 리액트 파이버가 하는 일

- 작업을 작은 단위로 분할하고 쪼개어 우선순위를 매김
- 작업을 일시 중지하고 다시 시작 가능
- 이전에 하던 작업을 재사용하거나 폐기 가능

> 모두 비동기로 작동

- 과거에는 스택으로 구현되어 동기적으로 작동
- 싱글 스레드라는 특징으로 인해 동기 작업이 중단될 수 없어 작업 중간에 다른 작업을 수행할 수 없음 -> 비효율성

#### 파이버의 구현

- 파이버는 하나의 작업 단위로 구성
- 작업을 하나씩 처리하고 `finishedWork()`으로 마무리
- 작업을 커밋해 실제 브라우저 DOM에 변경 사항 처리
  - 렌더 단계 : 모든 비동기 작업 수행하며 파이버의 작업, 우선순위, 중지, 폐기 등의 작업 수행
  - 커밋 단계 : DOM에 실제 변경사항을 반영하기 위해 `commitWork()`가 실행 -> 동기식 (중단 불가)

#### 리액트와 파이버

- 리액트는 가상 DOM이 아닌 Value UI, 즉 값을 가지고 있는 UI를 관리하는 라이브러리라는 것을 강조
- 파이버의 객체 값처럼 핵심 원칙은 UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것

### 리액트 파이버 트리

파이버 트리는 리액트 내부에서 두 개가 존재

- 현재 모습의 파이버 트리
- 작업 중인 상태를 나타내는 트리

리액트 파이버의 작업이 끝나면 작업 중인 트리(workInProgress)를 현재 트리로 바꿔버림 = 더블 버퍼링

#### 더블 버퍼링

- 보이지 않는 곳에서 다음으로 그려야 할 그림을 미리 그린 후, 완성된 새로운 그림을 현재 상태로 바꾸는 기법
- 컴퓨터 그래픽 분야의 용어
- 리액트에서는 커밋 단계에서 수행

### 파이버의 작업 순서

업데이트 발생 시

- 업데이트 요청을 받아 workInProgress 트리를 다시 빌드

> 가급적 새로운 파이버를 생성하지 않는다.

- 기존 객체를 재활용하여 내부 속성값만 초기화하거나 변경

## 4) 파이버와 가상 DOM

> 파이버

- 컴포넌트 정보를 파이버가 1:1로 소유
- 파이버는 비동기로 동작
- 실제 DOM에 반영하는 것은 동기
- 가상 DOM으로 메모리상에서 먼저 수행하고 최종적인 결과물만 실제 DOM에 적용

> 파이버와 가상 DOM은 동일한 개념이 아님

- 가상 DOM은 웹 어플리케이션에 해당
- 리액트 네이티브와 같은 환경에서도 사용가능한 파이버

## 5) 정리

가상 DOM과 리액트의 핵심

> DOM을 더욱 빠르게 그리고 반영하는 것이 아니라 바로 값으로 UI를 표현하는 것

# 3. 클래스 컴포넌트와 함수 컴포넌트

## 1) 클래스 컴포넌트

### 클래스 컴포넌트의 구조, 예제

```
import React from 'react';

interface SampleProps {
  required?: boolean;
  text: string;
}

interface SampleState {
  count: number;
  isLimited?: boolean;
}

class SampleComponent extends React.Component<SampleProps, SampleState> {
  private constructor(props: SampleProps) {
    super(props);
    this.state = {
      count: 0,
      isLimited; false,
    };
  }

  private handleClick = (0) => {
    const newValue = this.state.count + 1
    this.setState({ count: newValue, isLimited: newValue >= 10})
  }

  public render() {
    const {
      props: {required, text},
      state: {count, isLimited},
    } = this

    return {
      <h2>
      Sample Component
      <div>{required ? '필수' : '필수아님'}</div>
      <div>문자: {text}</div>
      <div>count: {count}</div>
      <button onClick={this.handleClick} disabled={isLimited}>
        증가
      </button>
      </h2>
    }
  }
}

```

### 클래스 컴포넌트의 생명주기 메서드

생명주기 메서드가 실행되는 시점

- 마운트 : 컴포넌트가 마운팅(생성)
- 업데이트 : 이미 생성된 컴포넌트의 내용이 변경
- 언마운트 : 컴포넌트가 더 이상 존재하지 않음

#### render()

- 클래스 컴포넌트의 유일한 필수 값
- 마운트, 업데이트 과정에서 실행
- 순수하고 부수 효과가 없어야 (내부에서 state 변경 불가)

#### componentDidMount()

- 마운트가 되고 준비되는 즉시 실행
- 내부에서 state 변경 가능

#### componentDidUpdate()

- 컴포넌트 업데이트가 일어난 이후 바로 실행
- state, props 변화에 따라 DOM을 업데이트 하는 등에 사용
- 내부에서 state 변경 가능

#### componentWillUnmount()

- 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출
- 메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 좋음
- state 변경 불가

#### shouldComponentUpdate()

- state, props의 변경으로 인한 리렌더링을 막고 싶을 때 사용
- 컴포넌트에 영향을 받지 않는 변화에 대해 정의 가능

#### static getDerivedStateFromProps()

- render() 호출하기 직전에 호출
- static으로 선언되어 있어 this에 접근할 수 없다
- 모든 render() 실행시에 호출

#### getSnapShotBeforeUpdate()

- DOM 업데이트 직접에 호출
- 반환된 값이 componentDidUpdate로 전달
- DOM 렌더링 전 윈도우 크기 조절하거나 스크롤 위치를 조정하는 등에 유용

#### getDerivedStateFromError()

- 에러 상황에서 실행
- 자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러
- 에러 처리 로직을 구현할 때 사용

#### componentDidcatch

- 자식 컴포넌트에서 에러가 발생했을 때 실행
- getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행
- 부수 효과 수행 가능 -> 커밋 단계에서 실행되기 때문

### 클래스 컴포넌트의 한계

> 클래스 컴포넌트에서 함수 컴포넌트, 훅을 도입한 새로운 패러다임으로 전환된 이유?

- 데이터 흐름 추적 어려움 : 클래스 컴포넌트의 여러 메서드에서 state 업데이트가 발생할 수 있으며, 코드 작성 시 생명주기 메서드를 실행 순서와 동일하게 작성하도록 강제할 수 없기 때문에 읽기가 어렵다.
- 애플리케이션 내부 로직 재사용이 어려움
- 기능이 많아질수록 컴포넌트 크기가 커짐 : 내부 데이터 흐름이 복잡해지며 메서드 사용이 잦아지고 컴포넌트 크기가 커진다.
- 클래스는 함수에 비해 어려움 : 자바스크립트 문법 상 함수보다 크래스가 최신 문법이라, 자바스크립트 개발자는 함수에 더 익숙함
- 코드 크기 최적화 어려움 : 번들 크기를 줄이는데도 어려움
- 핫 리로딩에 불리 : 클래스 컴포넌트는 instance에서 state를 관리하기 때문에 이 instance 내부의 render를 수정하면 instance를 새로 만들어 수정사항을 반영해야 하므로, 새로 만드는 과정에서 instance 값이 초기화 됨

## 2) 함수 컴포넌트

(클래스 컴포넌트보다 간결하다는 짧은 내용)

## 3) 함수 컴포넌트 vs 클래스 컴포넌트

### 생명주기 메서드의 부재

> 함수 컴포넌트에서는 존재하지 않음

- 함수 컴포넌트 : props를 받아 리액트 요소를 반환
- 클래스 컴포넌트 : render 메서드가 있는 React.component를 상속받아 구현
  - 생명주기 메서드는 React.component에 있음

### 함수 컴포넌트와 렌더링된 값

> 함수 컴포넌트는 렌더링된 값을 고정하고, 클래스 컴포넌트는 그렇지 못함

- 함수 컴포넌트 : 렌더링마다 그 순간의 값인 props, state를 기준으로 렌더링됨
- 클래스 컴포넌트 : 시간에 흐름에 따라 변화하는 this를 기준으로 렌더링됨

### 클래스 컴포넌트를 공부해야 할까?

> 사라질 계획은 없음

- 일부 클래스 컴포넌트의 메서드, 특히 자식 컴포넌트에서 발생한 에러에 대한 처리는 현재 클래스 컴포넌트에서만 가능하므로 에러 처리 부분에서는 클래스 컴포넌트에 대한 지식 필요
